#pragma config(Sensor, S1,     lrGyro,         sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Sensor, S4,     fbGyro,         sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Motor,  motorA,          frontMotor,    tmotorEV3_Large, openLoop, reversed, encoder)
#pragma config(Motor,  motorB,          backMotor,     tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          leftMotor,     tmotorEV3_Large, openLoop, reversed, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Medium, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// you need:
// - robotC ... you can download a trial version under 'http://www.robotc.net/' ... make sure to activate the 'natural language' option
// - a '4-wheel balancer robot' including
// 		- two gyro sensors (one for the forward-backward axis the other one for the left-right axis)
//		-	4 motors driving four 58mm omni-wheels ( http://www.robotshop.com/en/58mm-plastic-omni-wheel-lego-nxt-servo.html )
// - a basketball (size 5)
//
// I have not found any construction plans for a ball-balancing robot. I have choosen a very simple mechanical approach.
// just watch the video https://youtu.be/KPKlMlJ5BVk or https://youtu.be/swp7uNFtmfo to see the basic idea ...
//
//
// the following approach is using 4 parallel working PID controllers for each axis (forward-backward==pitch and left-right==roll)
//
// (1) 'gyro_speed': contolling the gyro speed
// (2) 'gyroAngle': controlling the gyro angle
// (3) 'robot_position': controlling the robot position
// (4) 'robot_speed': controlling the robot speed
//
// this approach gives a lot of room for parameter optimizations and is a very good example how a
// combination of several PID controllers can work. The basic idea is explained below in more detail.
//
//
// generally this 'challenge' is very similar to the gyroboy/segway example. The main difference is that
// you need a full set of controllers for each axis (so you end up with 8 PID controllers)
//
// why do we need all these parameters to balance a robot (lets focus just one axis for now)?
//
// I am sure that there are a lot of robot fans out there that have tried to balance
// a robot just by using a simple control loop using the gyro.
// Imagine the robot is balanced and starts to fall forward. A simple PID conntrol loop approach
// could use just the gyro angle to calculate the motor power that is needed to reduce the angle
// (the error) again (driving the ball 'under' the robot again). If the parameters are chosen properly the robot will be in the balanced status
// again (anytime soon). The problem is that there is no need (from the physical point of view) to reduce
// (no 'force' that is reducing) the speed of the robot (the speed is the result of the acceleration phase
// that was necessary to get the robot back into the balanced status).
// As a consequence the robot is balanced for a while but the speed/position is not controlled
// and so you end up with a robot at full speed (after a quite short time) without the possibility to control the balancing anymore.
// So it is clear that we have to control the speed/position of the robot somehow.
// the gyro control loops in this solution are nothing special. The motor power is 'proportional' (depending on the PID parameters) to the gyro angle/speed
// (obviously the reference for these PID controllers is 0 here).
//
// for the speed/position controller loop we have to consider the following fact:
// imagine that the robot is a few mm behind the ideal reference position in a 'perfectly' balanced status. So we have to move forward to correct the position
// (to minimize the position error).
// to move forward it is not 'allowed' just to move forward (driving the ball forward) because the robot would fall onto the backside.
// to move forward the robot must move backwards first (driving the ball backward) and than accelerate the ball forward (here the gyro control loop is doing the job)
// to balance again == driving the ball under the robot again (this is the way a balancing robot can make a 'step' forward).
// In other words we have to set the motor power to end up with a positive feedback (instead of a negative) to be able to move forward afterwards to reach the reference position
// (that means that we are increasing the position PID error in order to get the possibility to minimize the same error afterwards.
// The bigger the distance to the reference point in our example
// (the bigger the error) the more we must accelerate/move into the opposite direction to make a bigger step forward afterwards (the acceleration forward is 'triggered' by
// the gyro control loops as soon the robot starts to fall forward)
// (--> so a 'classic' PID approach should work fine but the output of the position and speed PID must be weighted negative to the motor power)
// the same concept/background is valid for the robot speed ...
//
// if we are doing the same for both axis we end up with a robot that is able to balance on a ball.
//
// to find working PID parameter sets is quite painfull and more tricky compared to the segway problem. The main reason for that is the fact that the robot wheels are small
// compared to the ball which is going hand in hand with a quite small maximum speed of the ball. This is limiting the possible 'dynamic' of the PID controllers significantly.
//
// for those who are interested in the mathematical background I can recommend
// https://en.wikipedia.org/wiki/PID_controller
// the wiki article is covering some complex mathematical theories and you might have leran a lot more to be able to undertand everything in detail.
// a very nice 'easy to understand' artircle about PID controllers you can find under
// http://www.inpharmix.com/jps/PID_Controller_For_Lego_Mindstorms_Robots.html



//***************************************************************************************************************************************************************
// and here is the code in RobotC with natural language option enabled ....


// Pragmas for showing different debug windows
//#pragma DebuggerWindows("Locals")
//#pragma DebuggerWindows("Globals")
//#pragma DebuggerWindows("DebugStream")
//#pragma DebuggerWindows("EV3LCDScreen")

#define pi ( 3.14159265 )					// needed to calculate the speed in mm/sec and the robot position in mm


// Power limit (+/- POWER_LIMIT) for motors
#define POWER_LIMIT ( 100 )
// Power limit (+/- POWER_LIMIT) for steering
#define STEERING_LIMIT ( 20 )


// 'Requested' sample time in milliseconds
#define sampleTime  ( 20.0 )					// 20ms seems to work fine without any timing overflows

// Wheel diameter in mm -- needed to compute robot position in mmm and robot speed in mmm/sec
// general: the bigger the wheels the better because max speed is higher (see pid_corr_dia)
float wheelDiameterIn_mm = 58.0;
// Convert wheel diameter to radius in mm
float wheelRadius = wheelDiameterIn_mm / 2;

float ballDiameter_mm = 221;				// ball diameter in mm

float ball_wheel_corr = wheelDiameterIn_mm / ballDiameter_mm;


float pid_corr_dia = 1.0;							// todo: test different ball diameters ... maybe a simple correction factor is sufficient



/**
* Calibration of gyro and color sensor reference
* in case of an sensor offset this function returns the mean value of
* this offset
* while this function is called/running the robot has to be held in
* 'balanced' position
*/
void calibrate(float *biasfb, float *biaslr)
{
	int numberOfReadings = 500;
	writeDebugStreamLine( "Resetting gyro, keep robot still" );

	eraseDisplay();
	displayCenteredBigTextLine( 2, "SensorTest");

	resetGyro( fbGyro );
	resetGyro( lrGyro );
	sleep(1000);

	do
	{
		displayCenteredBigTextLine( 9, "rate fb:%d",getGyroRate( fbGyro ));
		displayCenteredBigTextLine( 12, "rate lr:%d",getGyroRate( lrGyro ));
		sleep(100);
	}while(!getButtonPress(buttonEnter));

	sleep( 1000 );
	eraseDisplay();
	displayCenteredBigTextLine( 6, "GyroCal");
	sleep( 2000 );

	playSound( soundShortBlip );

	*biasfb = 0.0;
	*biaslr = 0.0;
	// And now do the actual calibration
	for( int i = 0; i < numberOfReadings; i++ ) {
		*biasfb += getGyroRate( fbGyro );
		*biaslr += getGyroRate( lrGyro );
		displayCenteredBigTextLine( 9, "rate fb:%d",*biasfb/(i+1));
		displayCenteredBigTextLine( 12, "rate lr:%d",*biaslr/(i+1));
		sleep(5);
	}
	*biasfb /= numberOfReadings;
	*biaslr /= numberOfReadings;
	writeDebugStreamLine("gyroRateBias FB(used): %f", *biasfb );
	writeDebugStreamLine("gyroRateBias LR(used): %f", *biaslr );
	sleep( 2000 );
	playSound( soundShortBlip );
}


/**
* Initialize
* just reset the motors and the display
*/
void initialize()
{
	stopAllMotors();

	eraseDisplay();

	resetMotorEncoder( frontMotor );
	resetMotorEncoder( backMotor );

	resetMotorEncoder( leftMotor );
	resetMotorEncoder( rightMotor );

	sleep( 100 );
}


/**
* Read encoders and determine current robot speed and robot position in mm/s and mm.
*
* 8 angles of the encoders are buffered. The encoder speed is the difference of the
* 'actual angle' - the 'eldest angle'
* multiplying this difference with (wheel radius)*(pi/180) / delta T represents the
* robot speed in mm/sec
* the robot position is given by the actual encoder angle * (wheel radius)*(pi/180)
*/
#define MAX_ENCODER_VALUES ( 8 )
void readEncoders(tMotor motor, float *r_speed, float *r_position, float dT)
{
	static long encoderValuesfb[ MAX_ENCODER_VALUES ] = {0,0,0,0,0,0,0,0};
	static long encoderValueslr[ MAX_ENCODER_VALUES ] = {0,0,0,0,0,0,0,0};
	static int encoderValueIndexfb = 0;
	static int encoderValueIndexlr = 0;

	long *encoderValues;
	int *encoderValueIndex;

	if((motor == frontMotor) || (motor == backMotor))
	{
		encoderValues = &encoderValuesfb[0];
		encoderValueIndex = &encoderValueIndexfb;
	}
	else
	{
		encoderValues = &encoderValueslr[0];
		encoderValueIndex = &encoderValueIndexlr;
	}

	long avgEncoderValue = getMotorEncoder( motor );
	long eldest = encoderValues[ *encoderValueIndex ];
	encoderValues[ *encoderValueIndex ] = avgEncoderValue;
	if ( ++(*encoderValueIndex) == MAX_ENCODER_VALUES ) *encoderValueIndex = 0;

	*r_speed = wheelRadius * ball_wheel_corr * (( avgEncoderValue - eldest ) / ( dT * (MAX_ENCODER_VALUES) )) * (pi/180.0);
	*r_position = wheelRadius * ball_wheel_corr * avgEncoderValue * (pi/180.0);
}


/**
* Reads gyro and estimates angle and angular velocity
* only the gyro rate is used to 'measure' both paramaters.
* The actual sensor bias is eliminated.
* The bias is updated over time to handle a possible sensor drift
* the gyro angle is calculated by simple integration of the sensor rates
*/
void readGyro(tSensors gyro, float *g_speed, float *g_angle, float *gyroRateBias,float dT)
{
	// Estimate of the current robotAngleBias due to drifting gyro
	static float robotAnglefb = 0.0;
	static float robotAnglelr = 0.0;

	// define gyro rate bias update ratio (calculation is based on mean value)
	float gyroRateBiasUpdateRatio = 0.2;

	float currentGyroRateMeasurement = getGyroRate( gyro);

	float *robotAngle;

	if(gyro == fbGyro) robotAngle=&robotAnglefb;
	else robotAngle=&robotAnglelr;

	// Estimate gyroRateBias rate by updating the value slowly
	// By multiplying with dt we make scale meanUpdateRatio to 1 sec
	*gyroRateBias = *gyroRateBias * ( 1 - dT * gyroRateBiasUpdateRatio ) + currentGyroRateMeasurement * dT * gyroRateBiasUpdateRatio;
	// Angular velocity can be computed directly now
	*g_speed = currentGyroRateMeasurement - *gyroRateBias;
	// And angle is computed based on integration from last epoch
	*robotAngle += *g_speed * dT;

	*g_angle = *robotAngle;
}



/**
* PID control
* dmp: damping of the integral ( working value is something near but smaller  than 0 )
* sat: saturation of integral ( working value something like 'max_power'/ki )
*
* this PID implementation includes
* - derivative filtering (the derivative term is based on input derivate)
* - anti windup
* - setpoint (reference) weighting
*
*/
typedef struct
{
	float kp;
	float sw;

	float bi;
	float ad;
	float bd;
	float br;
	float saturation_low;
	float saturation_high;

	float input_old;
	float I;						// integral
	float D;						// derivative term
}PID;

/**
* set all gain factors/parameters of the specidfied PID controller
* kp									proprtianl gain
* ki									integral gain
* kd 									derivative gain
* setpoint_weigth			setpoint weight for the proportional
* Tf									derivative filter time constant  (kd/kp)/N  N=2..20
* Tt									anti-windup time constant
* saturation_low			anti-windup upper saturarion level
* saturation_high			anti-windup lower saturation level
* dT									sampling time
*/
void PID_init(PID *pid, float kp, float ki, float kd, float setpoint_weight, float Tf, float Tt, float saturation_low, float saturation_high, float dT)
{
	pid->kp = kp;
	pid->bi = ki * dT;
	pid->ad = Tf / (Tf + dT);
	pid->bd = kd / (Tf + dT);
	pid->br = dT / Tt;
	pid->saturation_low = saturation_low;
	pid->saturation_high = saturation_high;
	pid->sw = setpoint_weight;

	pid->D = 0;						// derivative term
	pid->I = 0;						// error integral
	pid->input_old = 0;			// used to calculate the derivative term based on measured value
}

float PID_calc(PID *pid, float reference, float input, float *curr_err)
{
	*curr_err = reference - input;
	float P = pid->kp * (pid->sw * reference - input);
	pid->D = pid->ad * pid->D - pid->bd * (input - pid->input_old);
	float v = P + pid->I + pid->D;
	float u = v;
	if(u > pid->saturation_high) u = pid->saturation_high;
	else if(u < pid->saturation_low) u = pid->saturation_low;
	pid->I = pid->I + pid->bi * (reference - input) + pid->br * (u - v);
	pid->input_old = input;

	return v;
}
/*****************




/**
* Propagates reference position based on wanted speed and time step.
* Returns updated referencePosition
*/
float position( float lastReferencePosition, float requestedSpeed, float dT )
{
	return lastReferencePosition + requestedSpeed * dT;
}



// gyro PID outputs / controllers for pitch control
float pidGyroAngleOutputfb,gyro_angle_errfb;							// gyro angle PID output and error
float pidGyroSpeedOutputfb,gyro_speed_errfb;							// gyro speed PID output and error
float gyroSpeedfb,gyroAnglefb;														// holding measured values of the gyro speed and angle
PID gyro_anglefb;																					// gyro angle PID controller
PID gyro_speedfb;																					// gyro speed PID controller

// gyro PID outputs / controllers for roll control
float pidGyroAngleOutputlr,gyro_angle_errlr;							// gyro angle PID output and error
float pidGyroSpeedOutputlr,gyro_speed_errlr;							// gyro speed PID output and error
float gyroSpeedlr,gyroAnglelr;														// holding measured values of the gyro speed and angle
PID gyro_anglelr;																					// gyro angle PID controller
PID gyro_speedlr;																					// gyro speed PID controller

// encoder PID outputs / controllers for pitch control
float pidRobotPositionOutputfb,robot_position_errfb;			// robot position PID output and error
float pidRobotSpeedOutputfb,robot_speed_errfb;						// robot speed PID output and error
float robotSpeedfb,robotPositionfb;  											// holding the measured values for robot position and speed
PID robot_positionfb;																			// robot position PID controller
PID robot_speedfb;																				// robot speed PID controller

// encoder PID outputs / controllers for roll control
float pidRobotPositionOutputlr,robot_position_errlr;			// robot position PID output and error
float pidRobotSpeedOutputlr,robot_speed_errlr;						// robot speed PID output and error
float robotSpeedlr,robotPositionlr;  											// holding the measured values for robot position and speed
PID robot_positionlr;																			// robot position PID controller
PID robot_speedlr;																				// robot speed PID controller


/**
* Main program
*/
#define ROBOT_SPEED_F (00.00)					// robot forward speed mm/sec
#define ROBOT_SPEED_L2R (0.00)				// robot left2right speed mm/sec
task main()
{
	//bool ir_remote = true;					// activate simple IR remote control

	// this is the requested robot speed in m/s
	float requestedSpeedfb=ROBOT_SPEED_F;
	float requestedSpeedlr=ROBOT_SPEED_L2R;

	// Counter for counting main loop entries used to measure the mean sample time
	unsigned long counter = 0;

	// Reference position in meters. Robot starts at position 0
	float referencePositionfb = 0.0;
	float referencePositionlr = 0.0;

	// hold the bias values for the gyro (measured in 'calibrate')
	float gyroRateBiasfb;
	float gyroRateBiaslr;


	// the whole balancing loop consists of 4 PID controllers for both axes (forward-backward and left-right).
	// (1) 'gyro_speed': contolling the gyro speed
	// (2) 'gyroAngle': controlling the gyro angle
	// (3) 'robot_position': controlling the robot position
	// (4) 'robot_speed': controlling the robot speed



	// (just for debugging...) Number of times the control loop did not meet its deadline
	int controlLoopTimerOverflow = 0;
	// used to calculate dT (sampling time)
	float time_sum;



	initialize();										// reset motors and display

	calibrate(&gyroRateBiasfb, &gyroRateBiaslr);			// get the gyro bias




	// all PID parameters are open to be optimized ;) ... current parameters are working nice but for sure there are better ones
	// for the momnent no derivative terms have been used. I am quite sure that there is some room to use them ;)

#ifdef working_parameters
  // this paramter set is a working starting point for further optimizations
	// initialize the PID controls
	// parameters for the gyro control loops
	// void PID_init(PID *pid, float kp, float ki, float kd, float setpoint_weight, float Tf, float Tt, float saturation_low, float saturation_high, float dT)
	PID_init(&gyro_anglefb, 26.8 * pid_corr_dia, 55.0 * pid_corr_dia, 0.362  * pid_corr_dia, 1.0, (0.362  * pid_corr_dia) / (26.8 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&gyro_speedfb, 1.08 * pid_corr_dia, 3.62 * pid_corr_dia, 0.0072 * pid_corr_dia, 1.0, (0.0072 * pid_corr_dia) / (1.08 * pid_corr_dia) / 15.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&gyro_anglelr, 26.8 * pid_corr_dia, 55.0 * pid_corr_dia, 0.362  * pid_corr_dia, 1.0, (0.362  * pid_corr_dia) / (26.8 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&gyro_speedlr, 1.08 * pid_corr_dia, 3.62 * pid_corr_dia, 0.0072 * pid_corr_dia, 1.0, (0.0072 * pid_corr_dia) / (1.08 * pid_corr_dia) / 15.0, 0.3, -100, 100, sampleTime/1000.0);

	// parameters for the encoder control loop (robot position and speed))
	// the output of both controllers (robot position and speed) must be 'subtracted' from the motor power.
	PID_init(&robot_positionfb, 3.62 * pid_corr_dia, 3.62  * pid_corr_dia, 0.0072 * pid_corr_dia, 0.2, (0.0072 * pid_corr_dia) / (3.62 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&robot_speedfb,   	1.81 * pid_corr_dia, 0.362 * pid_corr_dia, 0.0072 * pid_corr_dia, 0.2, (0.0072 * pid_corr_dia) / (1.81 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&robot_positionlr, 3.62 * pid_corr_dia, 3.62  * pid_corr_dia, 0.0072 * pid_corr_dia, 0.2, (0.0072 * pid_corr_dia) / (3.62 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&robot_speedlr,   	1.81 * pid_corr_dia, 0.362 * pid_corr_dia, 0.0072 * pid_corr_dia, 0.2, (0.0072 * pid_corr_dia) / (1.81 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
#endif


  // initialize the PID controls
	// parameters for the gyro control loops
	// void PID_init(PID *pid, float kp, float ki, float kd, float setpoint_weight, float Tf, float Tt, float saturation_low, float saturation_high, float dT)
	PID_init(&gyro_anglefb, 26.8 * pid_corr_dia, 55.0 * pid_corr_dia, 0.362  * pid_corr_dia, 1.0, (0.362  * pid_corr_dia) / (26.8 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&gyro_speedfb, 1.08 * pid_corr_dia, 3.62 * pid_corr_dia, 0.0072 * pid_corr_dia, 1.0, (0.0072 * pid_corr_dia) / (1.08 * pid_corr_dia) / 15.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&gyro_anglelr, 26.8 * pid_corr_dia, 55.0 * pid_corr_dia, 0.362  * pid_corr_dia, 1.0, (0.362  * pid_corr_dia) / (26.8 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&gyro_speedlr, 1.08 * pid_corr_dia, 3.62 * pid_corr_dia, 0.0072 * pid_corr_dia, 1.0, (0.0072 * pid_corr_dia) / (1.08 * pid_corr_dia) / 15.0, 0.3, -100, 100, sampleTime/1000.0);

	// parameters for the encoder control loop (robot position and speed))
	// the output of both controllers (robot position and speed) must be 'subtracted' from the motor power.
	PID_init(&robot_positionfb, 3.62 * pid_corr_dia, 3.62  * pid_corr_dia, 0.0072 * pid_corr_dia, 0.2, (0.0072 * pid_corr_dia) / (3.62 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&robot_speedfb,   	1.81 * pid_corr_dia, 0.362 * pid_corr_dia, 0.0072 * pid_corr_dia, 0.2, (0.0072 * pid_corr_dia) / (1.81 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&robot_positionlr, 3.62 * pid_corr_dia, 3.62  * pid_corr_dia, 0.0072 * pid_corr_dia, 0.2, (0.0072 * pid_corr_dia) / (3.62 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);
	PID_init(&robot_speedlr,   	1.81 * pid_corr_dia, 0.362 * pid_corr_dia, 0.0072 * pid_corr_dia, 0.2, (0.0072 * pid_corr_dia) / (1.81 * pid_corr_dia) / 10.0, 0.3, -100, 100, sampleTime/1000.0);


	eraseDisplay();

	writeDebugStreamLine("*** Starting main loop");

	float dT = (float)sampleTime / 1000.0;						// 'requested' sample time

	resetTimer( T1 );																	// time is used to measure the true sample time
	time_sum = 0.0;																		// prepare sample time measurement



	// balance the robot till the enter button is pressed
	while( !getButtonPress(buttonEnter) ) {


			// PID control of robot speed and position

			// measure current robot position and robot speed ... pitch
			readEncoders(frontMotor,&robotSpeedfb,&robotPositionfb, dT);

			// measure current robot position and robot speed ... roll
			readEncoders(leftMotor,&robotSpeedlr,&robotPositionlr, dT);

			// pitch
			// Get expected position based on current position and requested speed
			referencePositionfb = position( referencePositionfb, requestedSpeedfb, dT );
			// controllers for robot position and speed.
			pidRobotPositionOutputfb = PID_calc(&robot_positionfb, referencePositionfb, robotPositionfb, &robot_position_errfb );		// reference is 'next' position (depending on the requested robot speed)
			pidRobotSpeedOutputfb = PID_calc(&robot_speedfb, requestedSpeedfb, robotSpeedfb, &robot_speed_errfb );									// reference is the requested robot speed

			// roll
			// Get expected position based on current position and requested speed
			referencePositionlr = position( referencePositionlr, requestedSpeedlr, dT );
			// controllers for robot position and speed.
			pidRobotPositionOutputlr = PID_calc(&robot_positionlr, referencePositionlr, robotPositionlr, &robot_position_errlr );		// reference is 'next' position (depending on the requested robot speed)
			pidRobotSpeedOutputlr = PID_calc(&robot_speedlr, requestedSpeedlr, robotSpeedlr, &robot_speed_errlr );									// reference is the requested robot speed



			// PID control gyro angle and speed

			// Read the gyro and update gyroRateBias and robot angle ... pitch
			readGyro(fbGyro, &gyroSpeedfb, &gyroAnglefb, &gyroRateBiasfb, dT);
			// controller for gyro based balancing. Reference is 0 for speed and angle to balance the robot ... pitch
			pidGyroAngleOutputfb = PID_calc(&gyro_anglefb, 0, gyroAnglefb, &gyro_angle_errfb );
			pidGyroSpeedOutputfb = PID_calc(&gyro_speedfb, 0, gyroSpeedfb, &gyro_speed_errfb );

			// Read the gyro and update gyroRateBias and robot angle ... roll
			readGyro(lrGyro, &gyroSpeedlr, &gyroAnglelr, &gyroRateBiaslr, dT);
			// controller for gyro based balancing. Reference is 0 for speed and angle to balance the robot ... roll
			pidGyroAngleOutputlr = PID_calc(&gyro_anglelr, 0, gyroAnglelr, &gyro_angle_errlr );
			pidGyroSpeedOutputlr = PID_calc(&gyro_speedlr, 0, gyroSpeedlr, &gyro_speed_errlr );



			// just show the current measurements and PID error of the robot position and speed
			// to get an idea if everything is controlled as expected ... debug
			displayCenteredBigTextLine( 1, "angfb:%f",gyroAnglefb);
			displayCenteredBigTextLine( 3, "anglr:%f",gyroAnglelr);
			displayCenteredBigTextLine( 5, "ref:%f",referencePositionfb);
			displayCenteredBigTextLine( 7, "pos:%f",robotPositionfb);
			displayCenteredBigTextLine( 9, "per:%f",robot_position_errfb);
			//displayCenteredBigTextLine( 9, "per:%f",getColorHue (colorSensor));



#if	0
			// todo ... we could add some kind of remote control here
			if(ir_remote)
			{
		  	switch(getIRRemoteButtons(irSensor))
		  	{
		  		case IR_RED_UP: requestedSpeedfb += 1.0; break;
		  		case IR_RED_DOWN: requestedSpeedfb -= 1.0;break;
		  		case IR_BLUE_UP: requestedSpeedlr += 1.0; break;
		  		case IR_BLUE_DOWN: requestedSpeedlr -= 1.0;break;
		  		case IR_RED_UP_RED_DOWN : requestedSpeedfb = 0.0; break;
		  		case IR_BLUE_UP_BLUE_DOWN : requestedSpeedlr = 0.0;break;
		  		case IR_BEACON_MODE_ON : {requestedSpeedfb = 0.0; requestedSpeedlr = 0.0;};break;
		  		default: break;
		  	}
		  }
#endif



		  // pidRobotPositionOutput and pidRobotSpeedOutputfb must give 'positive feedback'
			// pidGyroAngleOutput and pidGyroSpeedOutputfb must give negative feedback
			// the actual signs are the result of the mechanical motor arrangement and setup
		  float fb_power = +pidRobotPositionOutputfb+pidRobotSpeedOutputfb+pidGyroAngleOutputfb+pidGyroSpeedOutputfb;
		  float lr_power = +pidRobotPositionOutputlr+pidRobotSpeedOutputlr-pidGyroAngleOutputlr-pidGyroSpeedOutputlr;


			// limit power for both motors (100 == maximum)
			if(fb_power>POWER_LIMIT) fb_power=POWER_LIMIT;
			else if(fb_power<-POWER_LIMIT) fb_power=-POWER_LIMIT;
			if(lr_power>POWER_LIMIT) lr_power=POWER_LIMIT;
			else if(lr_power<-POWER_LIMIT) lr_power=-POWER_LIMIT;

			setMotor( backMotor, fb_power );
			setMotor( frontMotor, fb_power );

			setMotor( rightMotor, lr_power );
			setMotor( leftMotor, lr_power );

			// check if we have a sample time overflow
			// should never happen. In case just increase 'sampleTime'
			if ( getTimer( T1, milliseconds ) > sampleTime ) controlLoopTimerOverflow++;

			// measure mean dt (== loop duration == sample time)
			while( getTimer( T1, milliseconds ) < sampleTime  ) {};			// wait till we have sampleTime
			time_sum += getTimer( T1, milliseconds ) / 1000;
			resetTimer( T1 );
			dT = time_sum / (++counter);
		}



		stopAllMotors();

		eraseDisplay();
		displayCenteredBigTextLine( 4, "OVF: %4d", controlLoopTimerOverflow );


		sleep(30000);

	}
